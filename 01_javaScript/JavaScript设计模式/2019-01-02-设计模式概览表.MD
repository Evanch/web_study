---
title: 设计模式概览表
tag: 'tags'
tags:
  - 设计模式
---

# 设计模式概览表

|            设计模式            |                                                          描述                                                          |
| :----------------------------: | :--------------------------------------------------------------------------------------------------------------------: |
|    Factory Method 工厂模式     |                                         通过将数据和事件接口化来构建若干个子类                                         |
| Abstract Factory 抽象工厂模式  |                                   建立若族类的一个实例，者实例不需要具体类的细节信息                                   |
|       Builder 建造者模式       |                              将对象的构建方法和其表现形式分离开来，总是构建相同类型的对象                              |
|       Prototype 原型模式       |                                         一个完全初始化的实例，用于拷贝或者克隆                                         |
|         Singleton 单例         |                            一个类只有唯一的一个实例，这个实例在整个过程中有一个全局的访问点                            |
|       Adepter 适配器模式       |                    讲不通的接口进行匹配，调整，这样尽管颞部接口不兼容但是不同的类还是可以协同工作的                    |
|       Composite 组合模式       | 通过将简单可组合的对象组合起来，构成一个完成的对象，这个对象的能力将会超过这些组成部分的能力的总和，即会有新的能力产生 |
|        Bridge 桥接模式         |                              将对象的接口从其实现中分离，这样对象的实现和几口可以独立变化                              |
|      Decorator 装饰器模式      |                                           动态给对象增加一些可替换的处理流程                                           |
|       Flyweight 外观模式       |                                 一个类隐藏了内部子系统的复杂度，只暴露出一些简单的接口                                 |
|         Proxy 代理模式         |                                       一个充当占位符的对象用来代表一个真实的对象                                       |
|     Interpretr 解释器模式      |                             将语言元素包含在一个应用中的一种方式，用于匹配在目标语言的语法                             |
|  Template Method 模板方法模式  |                          在一个方法中为某个算法进阿里一层外壳，将算法的具体步骤交付给子类去做                          |
| Chain of Responsibility 响应链 |                              一种将请求在一串对象中传递的方式，寻找可以处理这个请求的对象                              |
|        Command 命令模式        |             封装命令请求一个对象，从而使记录日志，队列缓存请求，未处理请求进行错误处理，，这些功能成为可能             |
|      Mediator 中介者模式       |                             在类之间定义简化的通信方式，用于避免类之间显式的持有彼此的引用                             |
|        Iterator 迭代器         |                            在不需要知道集合内部工作原理的情况下，顺序访问一个集合里面的元素                            |
|      Observer 观察者模式       |                                  用于将变化通知给多个子类的方式，可保证类之间的一致性                                  |
|         State 状态模式         |                                            当对象状态改变时，改变对象的行为                                            |
|       Strategy 策略模式        |                                         将算法封装到类中，将选择和实现分离开来                                         |
|       Visitor 访问者模式       |                                             为类增加新的操作而不改变类本身                                             |
